package com.pretius.jddl.action.impl;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.pretius.jddl.DynamicObjectDeserializer;
import com.pretius.jddl.JddlException;
import com.pretius.jddl.model.DeserializationAction;
import com.pretius.jddl.model.DeserializationEvent;
import com.pretius.jddl.model.DeserializationResult;
import com.pretius.jddl.model.impl.DeserializationEventImpl;
import com.pretius.jddl.model.impl.DeserializationResultImpl;
import com.pretius.jddl.util.JddlReflectionUtils;

/**
 *  Deserializes a JSON object by deserializing each field separately. Calls rule-based serialization of {@link DynamicObjectDeserializer}
 * for each field. <br/>
 * Inspects each field looking for {@link JsonProperty} to change the field's name or {@link JsonIgnore} to ignore the field. 
 * All other Jackson annotations ignored. <br/>
 * The name in the {@link DeserializationEvent} generated by this action will be set according to {@link JsonProperty} name. 
 * Note that there may be rules that further change the field's name.
 * 
 * @author Dariusz Wawer
 *
 */
public class DeserializeObjectAction {

    // declared here to make the lambda's actual class visible in logs
    public static DeserializationAction getLambda() {
        return DeserializeObjectAction::deserialize;
    }
    
    public static DeserializationResult deserialize(DeserializationEvent event)
            throws InstantiationException, IllegalAccessException, IOException
    {
        return deserializeObject(event.getJsonNode(), event.getParentJsonNode(), event.getExpectedType(), event.getFieldName(), 
                event.getObjectMapperSupplier(), event.getEventHandle());
    }
    
    public static DeserializationResult deserializeObject(JsonNode node, JsonNode parentNode, Type expectedType, String fieldName, 
            Supplier<ObjectMapper> objectMapperSupplier, DeserializationAction deserializeEventHandler)
            throws InstantiationException, IllegalAccessException, IOException
    {
        if (expectedType == null) {
            throw new JddlException("No type specified and no found in node " + node.toString());
        }
        if (!(expectedType instanceof Class)) {
            throw new JddlException("Expected a Class Type for object deserialization, found=["+expectedType.getClass()+"]"
                    + " value=["+expectedType+"] in json=[" + node.toString()+"]");
        }
        
        Class<?> clazz = (Class<?>) expectedType;
        // if clazz is a map or any other interface it should be handled separately
        if (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {
            throw new JddlException(
                    "attempted to deserialize uninstatiable class " + clazz.getName());
        }

        Object obj = JddlReflectionUtils.createNewInstance(clazz);

        Set<Field> allFields = JddlReflectionUtils.getAllFields(clazz);
        Map<String, Field> objectFields = buildFieldNameToObjMap(allFields);
        Set<String> ignoredFieldNames = allFields.stream()
                .filter(field -> Modifier.isTransient(field.getModifiers()) || hasJsonIgnoreAnnotation(field))
                .map(Field::getName)
                .collect(Collectors.toSet());
        for (Iterator<Entry<String, JsonNode>> iterator = node.fields(); iterator.hasNext();) {
            Entry<String, JsonNode> entry = iterator.next();
            if (ignoredFieldNames.contains(entry.getKey())) {
                continue;
            }
            if (!objectFields.containsKey(entry.getKey())) {
                throw new JddlException(
                        "No key '" + entry.getKey() + "' in class " + clazz.getName());
            }

            Field field = objectFields.get(entry.getKey());
            if (field == null) {
                // otherProperties ?
                throw new JddlException("unhandled property " + entry.getKey() + " in " + fieldName);
            } else {
                Type parameterizedType = field.getGenericType();
                DeserializationResult res = deserializeEventHandler.deserialize(new DeserializationEventImpl(entry.getKey(),
                        entry.getValue(), node, parameterizedType, objectMapperSupplier, deserializeEventHandler));
                setValueReflection(obj, res.getFieldName(), res.getValue());
            }
        }

        return new DeserializationResultImpl(fieldName, obj);
    }


    private static boolean hasJsonIgnoreAnnotation(Field field) {
        JsonIgnore annotation = field.getAnnotation(JsonIgnore.class);
        return annotation != null;
    }
    
    static String getFieldJsonName(Field a) {
        JsonProperty annotation = a.getAnnotation(JsonProperty.class);
        if (annotation != null) {
            return annotation.value();
        } else {
            return a.getName();
        }
    }
    
    static boolean setValueReflection(Object object, String fieldName, Object fieldValue) {
        Class<?> clazz = object.getClass();
        try {
            Set<Field> allFields = JddlReflectionUtils.getAllFields(clazz);
            Map<String, Field> objectFields = buildFieldNameToObjMap(allFields);
            Field field = objectFields.get(fieldName);
            field.setAccessible(true);
            field.set(object, fieldValue);
            return true;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }


    private static Map<String, Field> buildFieldNameToObjMap(Set<Field> allFields) {
        Map<String, Field> objectFields = allFields.stream()
                .collect(Collectors.toMap(DeserializeObjectAction::getFieldJsonName, field -> field));
        return objectFields;
    }
}
